---
title: Context
label: Context
order: 50
desc: Context allows you to pass in extra data that can be shared between hooks
keywords: hooks, context, payload context, payloadcontext, data, extra data, shared data, shared, extra
---

<Banner type="info">
	Context is a useful way to pass extra data between hooks
</Banner>

Say you have a beforeChange and an afterChange hook. What if you wanted to make variables from the beforeChange hook available in the afterChange hook?

Of course, you could create a hidden field in your collection and store the data there, but that's not very elegant. Context makes it much easier to pass data between hooks.

Simply write or read data into the `context` object that is available to every hook. This data will persist throughout the entire lifecycle. You can also find the context in every request object: `req.context`.

Here are some examples of common usages on how to use context:

## Example 1: Passing data between hooks

```ts
const MyCollection: CollectionConfig = {
  slug: 'slug',
  hooks: {
    beforeChange: [({ context, data }) => {
      const {value1, value2} = await someCalculation();
      context.myCalculatedValue2 = value2;
      return {
        ....data,
        value: value1,
      };
    }],
    afterChange: [async ({ context, doc }) => {
      const documentID = doc.id;
      const value2 = context.myCalculatedValue2;
      await someExpensiveOperationWithDocumentIDAndValue2(documentID, value2);
    }],
  },
  fields: [
    {
      name: 'value',
      type: 'text',
    },
  ],
};
```

In this example, we calculate two values in the beforeChange hook - `value1` `and value2`. We set the document's field 'value' to `value1`, and now we want to pass `value2` to the afterChange hook.
That's because the afterChange hook needs `value2` + the document ID (which is not available in the beforeChange hook) for some expensive operation.

Since `value2` is not saved in the document, we aren't able to access it in the afterChange hook. But we can save it in the `context` object, which every hook has access to. We can then access it in the afterChange hook and use it for our operation.

## Example 2: Preventing infinite loops

Let's say you have an `afterChange` hook, and you want to do a calculation inside the hook (as the document ID needed for the calclulation is available in the afterChange hook, but not in the beforeChange hook). Once that's done, you want to update the document with the result of the calculation.

```ts
const MyCollection: CollectionConfig = {
  slug: 'slug',
  hooks: {
    afterChange: [async ({ doc }) => {
      const someValue = await someCalculationUsingDocID(doc.id);
      await payload.update({
        collection: 'slug',
        id: doc.id,
        data: {
          value: doc.value + someValue,
        },
      });
    }],
  },
  fields: [
    {
      name: 'value',
      type: 'text',
    },
  ],
};
```

You might not see it immediately, but this will go horribly wrong. Since the afterChange hook updates the document it's in, using `payload.update`, the afterChange hook will run again, update itself, then run again, and again - over and over. An infinite loop.

In order to prevent that, we need to tell the afterChange hook to not run again if it performs the update (and thus not update itself again). We can solve that with context:

```ts
const MyCollection: CollectionConfig = {
  slug: 'slug',
  hooks: {
    afterChange: [async ({ context, doc }) => {
      if (context.triggerAfterChange === false) { // Make sure we don't trigger afterChange again and again in an infinite loop
        return;
      }
      await payload.update({
        collection: contextHooksSlug,
        id: doc.id,
        data: {
          value: context.secretValue ?? '',
        },
        context: {
          triggerAfterChange: false, // Make sure we don't trigger afterChange again and again in an infinite loop.
        },
      });
    }],
  },
  fields: [
    {
      name: 'value',
      type: 'text',
    },
  ],
};
```

That's it! Now the afterChange hook will only run once, and not trigger itself again and again. Previously, we'd have to use a hidden checkbox field to do that - context makes it much easier.

## Passing context from the Rest API

Now, as you have seen in the example above, payload's local API has a `context` property which you can use to pass in context. But what about the Rest API?

In order to pass context, through the Rest API, you can use query parameters which you then parse in a `beforeOperation` hook. Here's how the hook could look like:

```ts
beforeOperation: [async ({ context, args }) => {
  const req: PayloadRequest = args.req;

  if (!req.query || !Object.keys(req.query).length) {
    return args;
  }

  Object.keys(req.query).forEach((key) => {
    if (key.startsWith('context_')) {
      // Strip 'context_' from key, add it to context object and remove it from query params
      const newKey = key.substring('context_'.length);
      context[newKey] = req.query[key];
      delete req.query[key];
    }
  });

  return args;
}],
```

Simply add this hook to your collection! In this implementation, the beforeOperation hooks moves every query parameter that starts with `context_` to the context object. So if you have a query parameter `context_secretValue`, it will be moved to context as `secretValue` and removed from the query parameters.

This is how you would then pass context through the Rest API:

```ts
const params = new URLSearchParams({
  context_secretValue: 'data from rest API',
});

// send context as query params. It will be parsed by the beforeOperation hook
const response = await fetch(`$http://localhost:3000/api/[collection-slug]?${params.toString()}`, {
  body: JSON.stringify({
    // ...
  }),
  method: 'post',
});
```

## Typing context

By default, context is untyped. However - especially for plugin development when a plugin adds context data to the context object - it's useful to have it typed.

We can do this using "type augmentation" - a TypeScript feature which allows us to add types to existing objects. Simply put this in any .ts or .d.ts file:

```ts
import { RequestContext as OriginalRequestContext } from 'payload';

declare module 'payload' {
  // Create a new interface that merges your additional fields with the original one
  export interface RequestContext extends OriginalRequestContext {
    myobject?: string;
    // ...
  }
}
```

This will add a fully-typed `myobject` of type string to every context object. Make sure to follow this example correctly, as type augmentation can mess up your types if you do it wrong.
